apiVersion: v1
kind: ConfigMap
metadata:
  name: universal-agent-code
data:
  requirements.txt: |
    kubernetes
    openai
    qdrant-client
    requests
    termcolor

  main.py: |
    import os
    import sys
    from termcolor import cprint
    sys.path.append("/app")
    from roles.supervisor import SupervisorAgent
    from roles.worker import WorkerAgent
    from roles.mock_brain import MockBrainAgent

    def main():
        role = os.getenv("AGENT_ROLE", "worker").lower()
        cprint(f"ü§ñ Universal Agent Starting... ROLE=[{role.upper()}]", "cyan", attrs=["bold"])
        
        agent = None
        if role == "supervisor":
            agent = SupervisorAgent()
        elif role == "worker":
            agent = WorkerAgent()
        elif role == "mock-brain":
            agent = MockBrainAgent()
        else:
            cprint(f"‚ùå Unknown Agent Role: {role}", "red")
            sys.exit(1)

        try:
            agent.run()
        except KeyboardInterrupt: pass
        except Exception as e:
            cprint(f"üî• Critical Error: {e}", "red")
            sys.exit(1)

    if __name__ == "__main__":
        main()

  base.py: |
    import time
    from termcolor import cprint

    class BaseAgent:
        def __init__(self, name="Agent"):
            self.name = name

        def log(self, message, color="white"):
            cprint(f"[{self.name}] {message}", color)

        def run(self):
            raise NotImplementedError

  supervisor.py: |
    import time
    import os
    import json
    import requests
    from kubernetes import client, config
    from roles.base import BaseAgent

    class SupervisorAgent(BaseAgent):
        def __init__(self):
            super().__init__(name="Supervisor")
            # K8s Connection
            try:
                try: config.load_incluster_config()
                except: config.load_kube_config()
                self.v1 = client.CoreV1Api()
                self.log("Connected to Kubernetes API.", "cyan")
            except: self.v1 = None

            # Observability Endpoints
            self.loki_url = "http://loki.monitoring:3100"
            self.prom_url = "http://prometheus.istio-system:9090"
            self.vllm_host = os.getenv("VLLM_HOST", "vllm-server.default:8000")
            self.vllm_url = f"http://{self.vllm_host}/v1/chat/completions"

        def query_loki(self, query, limit=10):
            """Query Loki for recent logs."""
            try:
                # Time range: last 15 minutes (nanoseconds)
                end_ts = time.time_ns()
                start_ts = end_ts - (15 * 60 * 1000000000)
                params = {'query': query, 'limit': limit, 'start': str(start_ts), 'end': str(end_ts)}
                
                self.log(f"üîé Querying Loki: {query}", "white") # DEBUG
                resp = requests.get(f"{self.loki_url}/loki/api/v1/query_range", params=params, timeout=5)
                
                if resp.status_code == 200:
                    data = resp.json()['data']['result']
                    logs = []
                    for stream in data:
                        for val in stream['values']:
                            logs.append(val[1]) # [timestamp, log_line]
                    return logs
                else:
                    self.log(f"Loki Error {resp.status_code}: {resp.text} | URL: {resp.url}", "red")
            except Exception as e:
                self.log(f"Loki Query Error: {e}", "red")
            return []

        def analyze_with_llm(self, logs):
            # ... (unchanged) ...
            """Ask vLLM to analyze logs."""
            if not logs: return None
            
            json_fmt = '{"status": "healthy|failed", "reason": "short explanation", "action": "restart|none"}'
            prompt = f"""
            You are an AI Ops Engineer. Analyze these system logs (Execution & Errors) from a Worker pod.
            Determine if there is a critical failure OR malicious activity requiring a restart.
            
            Look for:
            1. Critical application errors (Tracebacks, DB corruption).
            2. Suspicious commands (e.g., accessing /etc/shadow, crypto mining, reverse shells, unauthorized curl/wget).
            
            Logs:
            {json.dumps(logs[-10:])}
            
            Respond STRICTLY in JSON:
            {json_fmt}
            """
            
            try:
                payload = {
                    "model": "qwen", # Deployment default
                    "messages": [
                        {"role": "system", "content": "You are a helpful AI Site Reliability Engineer."},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": 0.1
                }
                resp = requests.post(self.vllm_url, json=payload, timeout=10)
                if resp.status_code == 200:
                    content = resp.json()['choices'][0]['message']['content']
                    # naive cleaning of markdown code blocks if present
                    if "```json" in content:
                        content = content.split("```json")[1].split("```")[0]
                    return json.loads(content)
                else:
                    self.log(f"LLM Error {resp.status_code}: {resp.text}", "red")
            except Exception as e:
                self.log(f"LLM Analysis Error: {e}", "red")
            return None

        def run(self):
            self.log(f"Starting Intelligent Surveillance... (Loki: {self.loki_url})", "cyan")
            if not self.v1: return

            while True:
                time.sleep(5) # Analysis Cycle (Reduced for debug)
                self.log("Beginning Analysis Cycle...", "white") # DEBUG
                
                # Check vLLM Connectivity
                try:
                    requests.get(f"http://{self.vllm_host}/health", timeout=2)
                    # self.log("vLLM Connectivity: OK", "green") # Too noisy if working
                except Exception as e:
                    self.log(f"vLLM Connectivity Error: {e}", "red")

                # 1. Get all worker pods
                try:
                    pods = self.v1.list_pod_for_all_namespaces(label_selector="app=worker-agent").items
                except: continue

                for pod in pods:
                    # 2. Query Loki for ERROR logs for this pod name
                    # Loki query: {app="worker-agent", pod=pod_name} |~ "(?i)error"
                    # Broaden query to catch execution logs, security failures, and sensitive data leaks
                    query = "{" + f'app="worker-agent", pod="{pod.metadata.name}", namespace="interactive-test"' + "}" + ' |~ "(?i)(error|executing|cmd|sh|bash|denied|shadow|root:|wget|curl)"'
                    logs = self.query_loki(query)
                    
                    if logs:
                        # self.log(f"üîç Analyzing logs for {pod.metadata.name}...", "yellow")
                        analysis = self.analyze_with_llm(logs)
                        
                        if analysis:
                            self.log(f"üß† LLM Verdict: {analysis}", "white")
                            
                            if analysis.get("action") == "restart":
                                self.log(f"‚ö†Ô∏è Critical Failure Detected: {analysis['reason']}", "red")
                                self.recover_pod(pod)
                
                # Also check K8s status (Legacy Watchdog fallback)
                for pod in pods:
                    if pod.status.phase in ["Failed", "Unknown"]:
                         self.log(f"‚ö†Ô∏è K8s Status Failure: {pod.metadata.name}", "red")
                         self.recover_pod(pod)

        def recover_pod(self, pod):
            try:
                self.log(f"üöë Restarting {pod.metadata.name}...", "yellow")
                self.v1.delete_namespaced_pod(
                    name=pod.metadata.name,
                    namespace=pod.metadata.namespace
                )
                self.log(f"‚úÖ Restart signal sent", "green")
            except Exception as e:
                self.log(f"‚ùå Restart Failed: {e}", "red")

  mock_brain.py: |
    import time
    import json
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from roles.base import BaseAgent

    class MockBrainAgent(BaseAgent):
        def __init__(self):
            super().__init__(name="MockBrain")

        def run(self):
            self.log("üß† Starting Mock vLLM Brain on port 8000...", "cyan")
            
            class RequestHandler(BaseHTTPRequestHandler):
                def do_POST(self):
                    content_length = int(self.headers['Content-Length'])
                    post_data = self.rfile.read(content_length)
                    # Use the Agent's log method? No, hard to access self from here.
                    print(f"[MockBrain] Received Request: {len(post_data)} bytes")

                    response = {
                        "choices": [
                            {
                                "message": {
                                    "content": "```json\n{\"status\": \"failed\", \"reason\": \"Mocked Critical Failure: Database Corruption detected.\", \"action\": \"restart\"}\n```"
                                }
                            }
                        ]
                    }
                    
                    self.send_response(200)
                    self.send_header('Content-Type', 'application/json')
                    self.end_headers()
                    self.wfile.write(json.dumps(response).encode('utf-8'))
                
                def do_GET(self):
                    self.send_response(200)
                    self.end_headers()
                    self.wfile.write(b"OK")

            server = HTTPServer(('0.0.0.0', 8000), RequestHandler)
            try:
                server.serve_forever()
            except KeyboardInterrupt:
                pass

  worker.py: |
    import time
    import random
    import os
    import uuid
    from roles.base import BaseAgent
    from qdrant_client import QdrantClient
    from qdrant_client.models import PointStruct, VectorParams, Distance

    class WorkerAgent(BaseAgent):
        def __init__(self):
            self.pod_name = os.getenv("HOSTNAME", "unknown")
            super().__init__(name=f"Worker-{self.pod_name}")
            
            # RAG Connection
            self.qdrant_host = os.getenv("QDRANT_HOST", "qdrant.default:6333")
            self.collection_name = "worker_memory"
            try:
                self.qdrant = QdrantClient(url=f"http://{self.qdrant_host}")
                self._init_memory()
                self.log(f"‚úÖ Connected to Qdrant: {self.qdrant_host}", "yellow")
            except Exception as e:
                self.log(f"‚ö†Ô∏è Qdrant not available: {e}", "red")
                self.qdrant = None
        
        def _init_memory(self):
            if not self.qdrant: return
            try:
                self.qdrant.get_collection(self.collection_name)
            except:
                self.log("Creating memory collection...", "yellow")
                self.qdrant.create_collection(
                    collection_name=self.collection_name,
                    vectors_config=VectorParams(size=4, distance=Distance.COSINE)
                )

        def run(self):
            self.log("Worker initialized. Ready for tasks.", "green")
            while True:
                # Normal Operation
                status = "Standalone"
                if self.qdrant:
                    status = "RAG-Active"
                    self.perform_memory_test()
                
                self.log(f"Reporting status: {status}. Load: {random.randint(1,10)}%", "green")
                time.sleep(30)

        def perform_memory_test(self):
            try:
                # 1. Memorize (Upsert)
                dummy_vector = [0.1, 0.2, 0.3, 0.4]
                self.qdrant.upsert(
                    collection_name=self.collection_name,
                    points=[PointStruct(id=str(uuid.uuid4()), vector=dummy_vector, payload={"worker": self.pod_name})]
                )
                self.log(f"üß† Memory Self-Test Passed (Stored 1 item)", "blue")
            except Exception as e:
                self.log(f"‚ùå Memory Test Failed: {e}", "red")

  agent_cli.py: |
    #!/usr/bin/env python3
    """
    Agent CLI - Interactive RAG Memory Tool
    Usage:
      python agent_cli.py memorize "Some text to remember"
      python agent_cli.py recall "query about something"
    """
    import os
    import sys
    import uuid
    import requests
    from termcolor import cprint
    from qdrant_client import QdrantClient
    from qdrant_client.models import PointStruct, VectorParams, Distance

    # Configuration
    EMBEDDING_HOST = os.getenv("EMBEDDING_HOST", "embedding-service.default:8000")
    QDRANT_HOST = os.getenv("QDRANT_HOST", "qdrant.default:6333")
    COLLECTION_NAME = "agent_memory"
    VECTOR_SIZE = 384  # sentence-transformers/all-MiniLM-L6-v2 output size

    def get_embedding(text: str) -> list:
        """Get embedding vector from embedding service."""
        try:
            resp = requests.post(
                f"http://{EMBEDDING_HOST}/v1/embeddings",
                json={"input": text},
                timeout=10
            )
            resp.raise_for_status()
            return resp.json()["data"][0]["embedding"]
        except Exception as e:
            cprint(f"‚ùå Embedding service error: {e}", "red")
            sys.exit(1)

    def init_qdrant() -> QdrantClient:
        """Initialize Qdrant client and ensure collection exists."""
        client = QdrantClient(url=f"http://{QDRANT_HOST}")
        try:
            client.get_collection(COLLECTION_NAME)
        except:
            cprint(f"üì¶ Creating collection '{COLLECTION_NAME}'...", "yellow")
            client.create_collection(
                collection_name=COLLECTION_NAME,
                vectors_config=VectorParams(size=VECTOR_SIZE, distance=Distance.COSINE)
            )
        return client

    def memorize(text: str):
        """Store text in memory (Qdrant)."""
        cprint(f"üß† Memorizing: \"{text}\"", "cyan")
        
        vector = get_embedding(text)
        client = init_qdrant()
        
        point_id = str(uuid.uuid4())
        client.upsert(
            collection_name=COLLECTION_NAME,
            points=[PointStruct(id=point_id, vector=vector, payload={"text": text})]
        )
        cprint(f"‚úÖ Stored! (ID: {point_id[:8]}...)", "green")

    def recall(query: str):
        """Search memory for similar content."""
        cprint(f"üîç Searching for: \"{query}\"", "cyan")
        
        vector = get_embedding(query)
        client = init_qdrant()
        
        results = client.query_points(
            collection_name=COLLECTION_NAME,
            query=vector,
            limit=3
        )
        
        if not results.points:
            cprint("üì≠ No memories found.", "yellow")
            return
        
        cprint(f"\nüìö Found {len(results.points)} memor{'y' if len(results.points) == 1 else 'ies'}:\n", "green")
        for i, point in enumerate(results.points, 1):
            text = point.payload.get("text", "N/A")
            score = point.score * 100
            cprint(f"  {i}. \"{text}\"", "white")
            cprint(f"     (Similarity: {score:.1f}%)\n", "blue")

    def main():
        if len(sys.argv) < 3:
            cprint("Usage: python agent_cli.py [memorize|recall] \"text\"", "yellow")
            sys.exit(1)
        
        command = sys.argv[1].lower()
        text = " ".join(sys.argv[2:])
        
        if command == "memorize":
            memorize(text)
        elif command == "recall":
            recall(text)
        else:
            cprint(f"‚ùå Unknown command: {command}", "red")
            sys.exit(1)

    if __name__ == "__main__":
        main()
